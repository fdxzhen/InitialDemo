[
  {
    "id": "JQ-001",
    "module": "Java基础",
    "difficulty": "初级",
    "type": "问答题",
    "title": "Java 中 == 和 equals() 有什么区别？",
    "answer": "== 比较的是引用地址或基本类型值；equals() 比较的是对象内容，除非被重写。",
    "exam_points": "理解引用与值的区别，对象比较机制。",
    "followups": "String 为什么推荐使用 equals()？重写 equals() 时需重写 hashCode() 吗？",
    "keywords": "equals,==,引用,比较"
  },
  {
    "id": "JQ-002",
    "module": "Java基础",
    "difficulty": "初级",
    "type": "问答题",
    "title": "Java 中有哪些基本数据类型？各占多少字节？",
    "answer": "byte(1), short(2), int(4), long(8), float(4), double(8), char(2), boolean(1位)。",
    "exam_points": "基本类型内存占用与范围。",
    "followups": "为什么 char 是 2 字节？float 和 double 哪个精度高？",
    "keywords": "基本类型,字节,内存,Java"
  },
  {
    "id": "JQ-003",
    "module": "Java基础",
    "difficulty": "初级",
    "type": "问答题",
    "title": "final 关键字有什么作用？",
    "answer": "final 可修饰变量、方法、类。变量不可重新赋值；方法不可被重写；类不可被继承。",
    "exam_points": "不可变性、继承约束。",
    "followups": "final 引用对象内容能变吗？final 与 immutability 区别？",
    "keywords": "final,关键字,不可变,继承"
  },
  {
    "id": "JQ-004",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "什么是 Java 内存模型（JMM）？",
    "answer": "JMM 定义了线程如何通过内存交互，主要包含主内存与工作内存的概念，解决可见性、有序性、原子性问题。",
    "exam_points": "多线程内存可见性，happens-before 原则。",
    "followups": "volatile 是如何保证可见性的？",
    "keywords": "JMM,内存模型,可见性,原子性"
  },
  {
    "id": "JQ-005",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "什么是装箱与拆箱？",
    "answer": "装箱是将基本类型转换为包装类型，拆箱反之。Java 自动完成此过程，如 Integer i = 5; 实际调用 Integer.valueOf(5)。",
    "exam_points": "自动装箱机制，缓存池。",
    "followups": "Integer 缓存范围是多少？为何 128 比较结果不同？",
    "keywords": "装箱,拆箱,包装类,Integer缓存"
  },
  {
    "id": "JQ-006",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "String、StringBuilder、StringBuffer 区别？",
    "answer": "String 不可变；StringBuilder 可变，非线程安全；StringBuffer 可变，线程安全（同步）。",
    "exam_points": "可变性与线程安全。",
    "followups": "为什么 String 被设计成不可变？",
    "keywords": "String,StringBuilder,StringBuffer,线程安全"
  },
  {
    "id": "JQ-007",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "谈谈 Java 中的异常体系。",
    "answer": "Throwable 分为 Error 和 Exception；Exception 又分 Checked 和 Unchecked。常见如 IOException、NullPointerException。",
    "exam_points": "异常分类与处理机制。",
    "followups": "为什么推荐捕获特定异常？",
    "keywords": "异常,Error,Exception,Checked"
  },
  {
    "id": "JQ-008",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "HashMap 的底层实现原理？",
    "answer": "JDK1.8 采用数组 + 链表 + 红黑树结构。通过 key 的 hashCode 定位桶，解决冲突使用链表或树化。",
    "exam_points": "哈希算法、负载因子、扩容机制。",
    "followups": "HashMap 在多线程下为什么不安全？ConcurrentHashMap 如何优化？",
    "keywords": "HashMap,底层结构,红黑树,哈希冲突"
  },
  {
    "id": "JQ-009",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "ArrayList 与 LinkedList 区别？",
    "answer": "ArrayList 基于数组，随机访问快；LinkedList 基于双向链表，插入删除快；ArrayList 扩容需复制数组。",
    "exam_points": "集合结构与性能差异。",
    "followups": "如何选择使用 ArrayList 或 LinkedList？",
    "keywords": "ArrayList,LinkedList,集合,性能"
  },
  {
    "id": "JQ-010",
    "module": "Java基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "谈谈 Java 中的多态。",
    "answer": "多态指同一方法在不同对象上表现出不同行为，通过继承与重写实现。运行时根据实际类型调用方法。",
    "exam_points": "面向对象三大特性之一。",
    "followups": "多态与重载的区别？",
    "keywords": "多态,重写,继承,Java OOP"
  },
  {
    "id": "COL-001",
    "module": "集合",
    "difficulty": "中级",
    "type": "问答题",
    "title": "ArrayList 和 LinkedList 有什么区别？",
    "answer": "ArrayList 基于动态数组实现，支持随机访问，插入删除慢；LinkedList 基于双向链表，插入删除快但随机访问慢。",
    "exam_points": "底层数据结构、时间复杂度、使用场景",
    "followups": "如果频繁在中间插入元素，选择哪个集合更合适？",
    "keywords": "ArrayList,LinkedList,集合,性能"
  },
  {
    "id": "COL-002",
    "module": "集合",
    "difficulty": "较难",
    "type": "问答题",
    "title": "HashMap 的底层结构是什么？JDK 1.8 之后做了哪些优化？",
    "answer": "底层是数组 + 链表 + 红黑树。JDK 1.8 之后当链表长度超过阈值（8）且数组容量大于 64 时，链表转换为红黑树以提升查询效率。",
    "exam_points": "HashMap 底层结构、红黑树引入原因、时间复杂度优化",
    "followups": "红黑树在极端情况下的性能如何？为什么不用 AVL 树？",
    "keywords": "HashMap,红黑树,底层结构,性能"
  },
  {
    "id": "COL-003",
    "module": "集合",
    "difficulty": "中级",
    "type": "问答题",
    "title": "如何实现线程安全的 List？",
    "answer": "可以使用 Collections.synchronizedList(new ArrayList<>()) 或使用 CopyOnWriteArrayList。",
    "exam_points": "线程安全集合、并发读写特性、适用场景",
    "followups": "CopyOnWriteArrayList 的写时复制机制有哪些优缺点？",
    "keywords": "线程安全,CopyOnWriteArrayList,Collections,同步"
  },
  {
    "id": "COL-004",
    "module": "集合",
    "difficulty": "较难",
    "type": "问答题",
    "title": "HashSet 是如何保证元素不重复的？",
    "answer": "HashSet 底层基于 HashMap，通过 key 的唯一性（hashCode + equals 判断）保证元素不重复。",
    "exam_points": "HashSet 与 HashMap 关系、hashCode 与 equals 契约",
    "followups": "如果重写 equals 但不重写 hashCode 会发生什么？",
    "keywords": "HashSet,HashMap,哈希,去重"
  },
  {
    "id": "COL-005",
    "module": "集合",
    "difficulty": "较难",
    "type": "问答题",
    "title": "ConcurrentHashMap 与 Hashtable 的区别是什么？",
    "answer": "Hashtable 使用同步锁锁住整个表，性能较差；ConcurrentHashMap 采用分段锁或 CAS + synchronized 机制，支持更高并发。",
    "exam_points": "并发控制机制、锁粒度、性能差异",
    "followups": "为什么 ConcurrentHashMap 在 JDK 8 中放弃了分段锁？",
    "keywords": "ConcurrentHashMap,Hashtable,线程安全,性能"
  },
  {
    "id": "COL-006",
    "module": "集合",
    "difficulty": "中级",
    "type": "问答题",
    "title": "TreeMap 是如何保证有序的？",
    "answer": "TreeMap 基于红黑树实现，按照 key 的自然顺序或 Comparator 自定义顺序排序。",
    "exam_points": "红黑树结构、排序机制、Comparator 应用",
    "followups": "如何实现一个倒序排列的 TreeMap？",
    "keywords": "TreeMap,红黑树,排序,Comparator"
  },
  {
    "id": "COL-007",
    "module": "集合",
    "difficulty": "较难",
    "type": "问答题",
    "title": "HashMap 是如何解决哈希冲突的？",
    "answer": "通过链地址法解决，即数组 + 链表结构；JDK 1.8 后链表过长时转为红黑树。",
    "exam_points": "冲突解决机制、负载因子、扩容机制",
    "followups": "HashMap 扩容时为什么需要重新计算 hash？",
    "keywords": "HashMap,哈希冲突,底层实现,扩容"
  },
  {
    "id": "COL-008",
    "module": "集合",
    "difficulty": "中级",
    "type": "问答题",
    "title": "当需要去重但保留插入顺序时，你会使用哪个集合？",
    "answer": "LinkedHashSet，在 HashSet 基础上增加双向链表维护插入顺序。",
    "exam_points": "有序去重、HashSet 扩展、链表维护顺序",
    "followups": "LinkedHashMap 与 LinkedHashSet 在实现上的关系？",
    "keywords": "LinkedHashSet,插入顺序,去重,HashSet"
  },
  {
    "id": "COL-009",
    "module": "集合",
    "difficulty": "初级",
    "type": "问答题",
    "title": "如何将数组转换为 List？",
    "answer": "使用 Arrays.asList(array) 或 Stream.of(array).collect(Collectors.toList())。",
    "exam_points": "集合与数组转换、asList 限制",
    "followups": "Arrays.asList 返回的 List 可以添加元素吗？为什么？",
    "keywords": "数组,List,转换,Arrays.asList"
  },
  {
    "id": "COL-010",
    "module": "集合",
    "difficulty": "中级",
    "type": "问答题",
    "title": "为什么 HashMap 的初始容量最好是 2 的幂？",
    "answer": "因为哈希寻址时采用 (n-1)&hash 计算索引，2 的幂能保证哈希分布均匀，减少冲突。",
    "exam_points": "哈希分布原理、位运算优化",
    "followups": "如果不是 2 的幂，哈希分布会怎样？",
    "keywords": "HashMap,初始容量,哈希分布,位运算"
  },
  {
    "id": "CON-001",
    "module": "并发",
    "difficulty": "中级",
    "type": "问答题",
    "title": "乐观锁和悲观锁有什么区别？",
    "answer": "悲观锁假设会发生冲突，操作前加锁，如synchronized和ReentrantLock；乐观锁假设不会发生冲突，操作时检测，如CAS和版本号机制。悲观锁适合写多读少场景，乐观锁适合读多写少场景。",
    "exam_points": "锁策略、性能差异、适用场景、CAS原理",
    "followups": "在高并发读多写少场景中，为什么乐观锁比悲观锁性能高？",
    "keywords": "乐观锁,悲观锁,CAS,线程安全,锁"
  },
  {
    "id": "CON-002",
    "module": "并发",
    "difficulty": "中级",
    "type": "问答题",
    "title": "CAS（Compare And Swap）原理是什么？",
    "answer": "CAS 是一种乐观锁实现机制，通过比较内存中的值与期望值，如果相等则更新，否则重试。Java中通过Atomic系列类实现，底层依赖CPU原子指令，如x86的CMPXCHG。",
    "exam_points": "乐观锁实现,ABA问题,Atomic类,CPU原子操作",
    "followups": "CAS 会出现什么问题？如何解决ABA问题？",
    "keywords": "CAS,Atomic,ABA问题,乐观锁,原子操作"
  },
  {
    "id": "CON-003",
    "module": "并发",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java 内存模型（JMM）核心内容是什么？",
    "answer": "JMM定义了Java中线程与主内存交互的规则，保证在多线程环境下的可见性、原子性、有序性。关键概念包括volatile、happens-before原则、重排序与内存屏障。",
    "exam_points": "可见性、原子性、有序性、volatile, happens-before,重排序",
    "followups": "volatile 能保证原子性吗？happens-before 原则如何保证线程安全？",
    "keywords": "JMM,volatile,内存模型,线程安全,happens-before"
  },
  {
    "id": "CON-004",
    "module": "并发",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Java 线程池有哪些核心组成？",
    "answer": "核心组成包括：核心线程数corePoolSize、最大线程数maximumPoolSize、任务队列workQueue、线程存活时间keepAliveTime、线程工厂ThreadFactory、拒绝策略RejectedExecutionHandler。",
    "exam_points": "线程池参数,任务队列,线程复用,拒绝策略,性能优化",
    "followups": "如何选择合适的线程池类型来处理高并发任务？",
    "keywords": "线程池,ThreadPoolExecutor,corePoolSize,maximumPoolSize,并发"
  },
  {
    "id": "CON-005",
    "module": "并发",
    "difficulty": "中级",
    "type": "问答题",
    "title": "ThreadLocal 的原理和应用场景是什么？",
    "answer": "ThreadLocal为每个线程提供独立变量副本，通过Thread内部的ThreadLocalMap存储，实现线程隔离。常用于用户会话信息、数据库连接、事务管理等场景。",
    "exam_points": "线程隔离,内存泄漏风险,应用场景,ThreadLocalMap",
    "followups": "ThreadLocal使用不当可能导致什么问题？如何避免？",
    "keywords": "ThreadLocal,线程隔离,并发,内存泄漏,线程安全"
  },
  {
    "id": "CON-006",
    "module": "并发",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java 并发容器有哪些？它们的特点是什么？",
    "answer": "常见并发容器包括ConcurrentHashMap（分段锁/红黑树+CAS）、CopyOnWriteArrayList（写时复制）、ConcurrentLinkedQueue（非阻塞队列），它们通过分段锁或CAS保证线程安全。",
    "exam_points": "线程安全容器,锁分段,CAS,非阻塞队列,CopyOnWrite",
    "followups": "为什么写操作少、读操作多场景适合CopyOnWriteArrayList？",
    "keywords": "并发容器,ConcurrentHashMap,CopyOnWriteArrayList,ConcurrentLinkedQueue,线程安全"
  },
  {
    "id": "CON-007",
    "module": "并发",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Atomic 原子类有哪些？适用场景是什么？",
    "answer": "AtomicInteger、AtomicLong、AtomicReference等，通过CAS实现原子操作，适用于无锁并发计数、状态标记、引用更新等高并发场景。",
    "exam_points": "CAS原理,原子操作,无锁设计,Atomic类使用",
    "followups": "AtomicInteger 的 getAndIncrement 和 incrementAndGet 有何区别？",
    "keywords": "AtomicInteger,AtomicLong,AtomicReference,CAS,原子操作"
  },
  {
    "id": "CON-008",
    "module": "并发",
    "difficulty": "高级",
    "type": "问答题",
    "title": "AQS（AbstractQueuedSynchronizer）原理是什么？",
    "answer": "AQS是Java并发包核心框架，采用FIFO等待队列和状态标志state管理同步器。它支持独占锁（如ReentrantLock）和共享锁（如Semaphore），通过模板方法模式实现自定义同步器。",
    "exam_points": "同步器实现,FIFO队列,独占锁与共享锁,模板方法",
    "followups": "ReentrantLock 的公平锁和非公平锁是如何通过AQS实现的？",
    "keywords": "AQS,ReentrantLock,同步器,独占锁,共享锁,并发"
  },
  {
    "id": "CON-009",
    "module": "并发",
    "difficulty": "高级",
    "type": "问答题",
    "title": "CompletableFuture 在并发中有什么用？",
    "answer": "CompletableFuture 提供异步编程模型，可组合异步任务、处理依赖、支持异常处理。常用于多任务并行、回调处理和异步链式调用。",
    "exam_points": "异步编程,任务组合,异常处理,线程调度,ForkJoinPool",
    "followups": "thenCombine 和 thenCompose 的区别是什么？",
    "keywords": "CompletableFuture,异步,并发,任务组合,线程池"
  },
  {
    "id": "CON-010",
    "module": "并发",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Synchronized 关键字的原理和常见面试题",
    "answer": "Synchronized 是JVM层面的锁，依赖对象的monitor实现可重入锁，保证原子性和可见性。常见面试题包括锁升级（偏向锁、轻量锁、重量锁）、死锁场景、锁粒度选择。",
    "exam_points": "锁实现原理,可重入性,锁升级,锁粒度,死锁",
    "followups": "在高并发场景中，什么时候优先使用 ReentrantLock 而不是 synchronized？",
    "keywords": "synchronized,锁,并发,线程安全,死锁"
  },
  {
    "id": "JVM-001",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "深入理解Java虚拟机系列的核心内容是什么？",
    "answer": "《深入理解Java虚拟机》系列深入讲解了JVM架构、类加载机制、内存模型、垃圾回收算法、性能优化、线程同步等内容，重点关注面试中高频考点。",
    "exam_points": "JVM架构,类加载,内存模型,垃圾回收,性能优化",
    "followups": "这本书在面试中最常被问到的知识点有哪些？",
    "keywords": "Java虚拟机,JVM,面试,性能优化,垃圾回收"
  },
  {
    "id": "JVM-002",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-JVM内存区域有哪些？",
    "answer": "JVM内存主要分为方法区（存放类元数据）、堆（存放对象实例）、栈（存放局部变量）、程序计数器（记录当前执行指令地址）和本地方法栈（Native方法调用）。",
    "exam_points": "方法区,堆,栈,程序计数器,本地方法栈,内存分区",
    "followups": "栈和堆的区别是什么？在Java对象创建过程中各内存区如何参与？",
    "keywords": "Java虚拟机,内存区域,JVM,堆,栈,方法区"
  },
  {
    "id": "JVM-003",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-JVM内存分配与回收策略原理是什么？",
    "answer": "JVM堆内存分为新生代和老年代，采用分代收集策略。新生代多使用复制算法，老年代使用标记-清除或标记-整理，永久代或元空间存放类元数据。垃圾回收通过 Minor GC 和 Full GC 管理内存。",
    "exam_points": "分代收集策略,新生代,老年代,垃圾回收算法,内存管理",
    "followups": "为什么大对象会直接进入老年代？CMS和G1 GC有何不同？",
    "keywords": "Java虚拟机,垃圾回收,内存分配,GC,分代收集"
  },
  {
    "id": "JVM-004",
    "module": "Java虚拟机",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Java虚拟机-常用VM参数有哪些？",
    "answer": "常用VM参数包括：-Xms、-Xmx（堆大小），-XX:PermSize、-XX:MaxPermSize（永久代），-Xss（栈大小），-XX:+UseG1GC、-XX:+UseConcMarkSweepGC（GC策略），-XX:+PrintGCDetails（GC日志）。",
    "exam_points": "堆和栈设置,GC策略,日志打印,性能调优",
    "followups": "如何根据GC日志优化JVM性能？",
    "keywords": "Java虚拟机,VM参数,堆,栈,G1GC,CMS"
  },
  {
    "id": "JVM-005",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-如何利用JDK自带命令行工具监控高并发虚拟机性能？",
    "answer": "可以使用jstat、jmap、jstack、jconsole、jcmd等工具监控堆内存、GC活动、线程状态和类加载情况，从而分析高并发应用的性能瓶颈。",
    "exam_points": "jstat,jmap,jstack,jconsole,jcmd,性能监控,线程分析",
    "followups": "在百万级并发场景下，哪些JDK工具最有效？",
    "keywords": "Java虚拟机,JDK工具,性能监控,线程分析,高并发"
  },
  {
    "id": "JVM-006",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-如何利用VisualVM对高并发项目进行性能分析？",
    "answer": "VisualVM可以监控堆和栈的使用情况，分析CPU消耗和线程状态，进行堆转储(Hprof)分析对象分布，并可结合插件进行GC可视化和内存泄漏检测。",
    "exam_points": "VisualVM,堆栈分析,线程监控,性能分析,内存泄漏",
    "followups": "如何利用VisualVM排查高并发应用的内存泄漏问题？",
    "keywords": "Java虚拟机,VisualVM,性能分析,高并发,堆转储"
  },
  {
    "id": "JVM-007",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-GC算法原理有哪些？",
    "answer": "常见GC算法包括：标记-清除、标记-整理、复制算法、分代收集、CMS并发标记清除、G1分代+Region回收，目的是提高吞吐量和降低停顿时间。",
    "exam_points": "GC算法,分代收集,停顿时间,并发GC,G1 GC,CMS GC",
    "followups": "CMS和G1 GC在高并发系统中的选择原则是什么？",
    "keywords": "Java虚拟机,垃圾回收,GC算法,CMS,G1GC,内存管理"
  },
  {
    "id": "JVM-008",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-类文件结构和类加载过程是什么？",
    "answer": "类文件包含魔数、版本号、常量池、访问标志、字段、方法、属性。类加载过程包括加载（Load）、验证（Verify）、准备（Prepare）、解析（Resolve）、初始化（Initialize）五个阶段，由不同类加载器负责。",
    "exam_points": "类文件结构,类加载五阶段,类加载器,字节码验证",
    "followups": "双亲委派模型的作用是什么？",
    "keywords": "Java虚拟机,类加载,类文件结构,字节码,类加载器"
  },
  {
    "id": "JVM-009",
    "module": "Java虚拟机",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Java虚拟机-类加载器有哪几种类型？",
    "answer": "主要有引导类加载器(Bootstrap ClassLoader)、扩展类加载器(Extension ClassLoader)、系统类加载器(System ClassLoader)和自定义类加载器(Custom ClassLoader)。",
    "exam_points": "类加载器类型,双亲委派模型,类加载顺序,自定义加载器",
    "followups": "自定义类加载器如何实现热加载？",
    "keywords": "Java虚拟机,类加载器,Bootstrap,系统类加载器,自定义类加载器"
  },
  {
    "id": "JVM-010",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-JVM架构及运行原理是什么？",
    "answer": "JVM架构包括类加载子系统、运行时数据区（方法区、堆、栈、PC寄存器、本地方法栈）、执行引擎和本地接口。它负责加载字节码、执行指令、内存管理、GC及本地方法调用。",
    "exam_points": "JVM组成,类加载,执行引擎,内存管理,本地方法调用",
    "followups": "解释字节码执行的解释器与JIT编译器的区别和优势。",
    "keywords": "Java虚拟机,JVM架构,执行引擎,类加载,内存管理"
  },
  {
    "id": "JVM-011",
    "module": "Java虚拟机",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Java虚拟机-对象生命周期包括哪些阶段？",
    "answer": "对象生命周期包括创建（new）、使用（赋值、方法调用）、不可达/死亡（GC回收），JVM根据对象年龄决定新生代或老年代分配，并采用不同GC算法回收。",
    "exam_points": "对象分配,对象回收,GC,新生代老年代,引用类型",
    "followups": "弱引用、软引用、虚引用在对象回收中的作用是什么？",
    "keywords": "Java虚拟机,对象生命周期,垃圾回收,新生代,老年代"
  },
  {
    "id": "JVM-012",
    "module": "Java虚拟机",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Java虚拟机-String常量池原理是什么？",
    "answer": "String常量池存储在方法区（Java 7之后存放在堆），用于复用字符串对象。编译期的字面量放入池中，运行期intern方法可将字符串放入池，减少内存占用。",
    "exam_points": "字符串复用,intern方法,常量池位置,性能优化",
    "followups": "为什么使用String.intern可以减少内存开销？",
    "keywords": "Java虚拟机,String常量池,内存优化,intern,字符串复用"
  },
  {
    "id": "NET-001",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "OSI 和 TCP/IP 网络分层模型详解",
    "answer": "OSI 模型分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；TCP/IP 模型分为四层：网络接口层、网络层、传输层、应用层。两者在实际应用中，TCP/IP 模型更简化且被广泛采用。",
    "exam_points": "OSI七层, TCP/IP四层, 功能划分, 协议映射",
    "followups": "在实际开发中如何理解 TCP/IP 模型与 OSI 模型的对应关系？",
    "keywords": "OSI,TCP/IP,网络分层,协议栈,网络模型"
  },
  {
    "id": "NET-002",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "应用层常见协议总结",
    "answer": "应用层协议包括 HTTP/HTTPS（网页访问）、FTP（文件传输）、SMTP/POP3/IMAP（邮件）、DNS（域名解析）、Telnet/SSH（远程登录）等，用于不同应用场景的数据通信。",
    "exam_points": "HTTP,FTP,SMTP,DNS,远程登录协议",
    "followups": "在开发中如何选择不同的应用层协议？",
    "keywords": "应用层协议,HTTP,FTP,DNS,SMTP,SSH"
  },
  {
    "id": "NET-003",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "应用层 HTTP vs HTTPS",
    "answer": "HTTP 是明文传输协议，通信数据不加密；HTTPS 在 HTTP 基础上加入 SSL/TLS 加密，保证数据传输安全，防止中间人攻击和窃听。",
    "exam_points": "HTTP,HTTPS,加密传输,SSL/TLS,安全性",
    "followups": "HTTPS 相比 HTTP 性能上有什么影响？",
    "keywords": "HTTP,HTTPS,SSL,TLS,安全传输"
  },
  {
    "id": "NET-004",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "应用层 HTTP 1.0 vs HTTP 1.1",
    "answer": "HTTP 1.0 每次请求建立独立连接，1.1 引入持久连接（Keep-Alive）、管线化、Host 头部、多缓存机制等，提升性能和资源复用率。",
    "exam_points": "HTTP版本差异,持久连接,管线化,请求头变化",
    "followups": "为什么 HTTP 1.1 性能比 HTTP 1.0 好？",
    "keywords": "HTTP1.0,HTTP1.1,持久连接,管线化,请求头"
  },
  {
    "id": "NET-005",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "应用层 HTTP 常见状态码",
    "answer": "HTTP 状态码分为 1xx（信息）、2xx（成功）、3xx（重定向）、4xx（客户端错误）、5xx（服务器错误）。常用状态码：200 OK, 301/302 重定向, 404 Not Found, 500 Internal Server Error。",
    "exam_points": "状态码分类,常用状态码,HTTP响应理解",
    "followups": "在接口设计中如何合理使用状态码？",
    "keywords": "HTTP,状态码,200,404,500,301,302"
  },
  {
    "id": "NET-006",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "应用层 DNS 域名系统详解",
    "answer": "DNS 是域名解析系统，将域名映射为 IP 地址。核心组成包括根域名服务器、顶级域名服务器、权威域名服务器和本地域名解析器。解析流程包括递归查询和迭代查询。",
    "exam_points": "DNS组成,解析流程,递归与迭代,IP映射",
    "followups": "为什么 CDN 可以利用 DNS 优化访问速度？",
    "keywords": "DNS,域名解析,递归查询,迭代查询,CDN"
  },
  {
    "id": "NET-007",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "传输层 TCP 三次握手和四次挥手",
    "answer": "三次握手用于建立连接：客户端发送 SYN，服务端返回 SYN+ACK，客户端确认 ACK；四次挥手用于断开连接：客户端发送 FIN，服务端确认 ACK，服务端发送 FIN，客户端确认 ACK，保证双方完全关闭连接。",
    "exam_points": "三次握手,四次挥手,连接建立,连接释放,可靠通信",
    "followups": "为什么 TCP 断开连接需要四次挥手而不是三次？",
    "keywords": "TCP,三次握手,四次挥手,连接管理,传输层"
  },
  {
    "id": "NET-008",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "传输层 TCP 传输可靠性保障",
    "answer": "TCP 通过序列号、确认号、重传机制、流量控制（滑动窗口）、拥塞控制、校验和保证数据可靠传输，确保数据按顺序到达且不丢失。",
    "exam_points": "序列号,确认号,滑动窗口,重传机制,拥塞控制",
    "followups": "TCP 如何处理网络丢包和乱序问题？",
    "keywords": "TCP,可靠性,重传,流量控制,拥塞控制"
  },
  {
    "id": "NET-009",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "网络层 ARP 协议详解",
    "answer": "ARP（Address Resolution Protocol）用于将 IP 地址映射为 MAC 地址，通过广播请求 MAC 地址并接收目标设备响应，实现局域网内主机通信。",
    "exam_points": "ARP原理,IP-MAC映射,广播请求,局域网通信",
    "followups": "ARP 缓存是如何工作的？如何防止 ARP 攻击？",
    "keywords": "ARP,IP-MAC映射,局域网,广播,协议"
  },
  {
    "id": "NET-010",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "网络层 NAT 协议详解",
    "answer": "NAT（Network Address Translation）将私有网络地址转换为公网地址，实现内网主机访问互联网。类型包括静态 NAT、动态 NAT、端口映射（PAT）。",
    "exam_points": "NAT原理,地址转换,端口映射,私网与公网通信",
    "followups": "NAT 如何影响 P2P 应用通信？",
    "keywords": "NAT,私网,公网,地址转换,端口映射"
  },
  {
    "id": "NET-011",
    "module": "网络基础",
    "difficulty": "中级",
    "type": "问答题",
    "title": "网络安全 网络攻击常见手段总结",
    "answer": "常见网络攻击手段包括：DDoS攻击、SQL注入、XSS跨站脚本、CSRF跨站请求伪造、中间人攻击(MITM)、ARP欺骗、端口扫描、弱口令攻击等。",
    "exam_points": "攻击类型,防御措施,漏洞利用,网络安全基础",
    "followups": "在设计安全网络时，如何防御 DDoS 和 SQL 注入攻击？",
    "keywords": "网络安全,DDoS,SQL注入,XSS,CSRF,ARP欺骗"
  },
  {
    "id": "DB-001",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 索引详解",
    "answer": "MySQL 索引用于提高查询效率，常见类型包括 B+ 树索引、哈希索引、全文索引。索引可以加速 WHERE、ORDER BY、JOIN 等操作，但会增加写操作成本和占用空间。",
    "exam_points": "B+树索引,哈希索引,全文索引,索引优化,索引失效",
    "followups": "在实际项目中，如何判断是否需要创建索引？",
    "keywords": "MySQL,索引,B+树,哈希,查询优化"
  },
  {
    "id": "DB-002",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 事务隔离级别详解",
    "answer": "MySQL 支持四种事务隔离级别：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ（默认）、SERIALIZABLE。不同隔离级别解决脏读、不可重复读和幻读的方式不同。",
    "exam_points": "事务隔离级别,脏读,不可重复读,幻读,InnoDB 默认隔离级别",
    "followups": "为什么 InnoDB 默认使用 REPEATABLE READ 能防止幻读？",
    "keywords": "MySQL,事务,隔离级别,脏读,幻读"
  },
  {
    "id": "DB-003",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 三大日志详解",
    "answer": "MySQL 三大日志包括：binlog（记录逻辑变更，支持主从复制和增量备份）、redo log（重做日志，保证事务持久性）、undo log（回滚日志，支持事务回滚和 MVCC）。",
    "exam_points": "binlog,redo log,undo log,事务持久性,恢复机制",
    "followups": "MySQL 故障恢复时，三大日志如何协同工作？",
    "keywords": "MySQL,日志,binlog,redo log,undo log"
  },
  {
    "id": "DB-004",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "InnoDB 存储引擎对 MVCC 的实现",
    "answer": "InnoDB 通过 undo log 和多版本数据快照实现 MVCC（多版本并发控制），保证 REPEATABLE READ 隔离级别下的可重复读，同时提高并发性能。",
    "exam_points": "MVCC,undo log,快照读,并发控制,InnoDB",
    "followups": "为什么 MVCC 可以减少锁竞争？",
    "keywords": "MySQL,InnoDB,MVCC,并发控制,事务"
  },
  {
    "id": "DB-005",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "SQL 语句在 MySQL 中的执行过程",
    "answer": "SQL 执行流程包括：解析 SQL（语法解析和预处理）、优化器生成执行计划、存储引擎执行计划、返回结果。优化器决定使用索引、全表扫描或排序策略。",
    "exam_points": "解析,优化器,执行计划,存储引擎,索引使用",
    "followups": "如何通过 EXPLAIN 分析 SQL 执行效率？",
    "keywords": "MySQL,SQL执行,解析,优化器,执行计划"
  },
  {
    "id": "DB-006",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 查询缓存详解",
    "answer": "查询缓存会缓存 SELECT 查询结果，但仅适用于 MySQL < 8.0。更新表数据时会自动失效，现代 MySQL 多使用索引优化替代查询缓存。",
    "exam_points": "查询缓存,缓存失效,性能优化,SELECT查询",
    "followups": "为什么高并发场景下查询缓存可能不如索引高效？",
    "keywords": "MySQL,查询缓存,性能优化,SELECT"
  },
  {
    "id": "DB-007",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 执行计划分析",
    "answer": "通过 EXPLAIN 或 EXPLAIN ANALYZE 查看 SQL 执行计划，了解查询方式（全表扫描、索引扫描）、连接类型、行数估算、排序方式，从而进行优化。",
    "exam_points": "EXPLAIN,执行计划,索引选择,性能分析",
    "followups": "在大表查询中，如何根据执行计划优化 SQL？",
    "keywords": "MySQL,执行计划,EXPLAIN,性能优化"
  },
  {
    "id": "DB-008",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 自增主键一定是连续的吗？",
    "answer": "MySQL 自增主键不一定连续，由于事务回滚、服务器重启或批量插入失败，可能出现自增跳号，但仍保证唯一性。",
    "exam_points": "自增主键,唯一性,非连续性,事务回滚",
    "followups": "如何保证序列连续性？是否推荐？",
    "keywords": "MySQL,自增主键,事务,连续性"
  },
  {
    "id": "DB-009",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 时间类型数据存储建议",
    "answer": "建议使用 TIMESTAMP/DATE/DATETIME 类型存储时间，选择时考虑时区、存储大小和查询需求，避免使用字符串类型存储时间。",
    "exam_points": "时间类型,存储大小,时区问题,查询效率",
    "followups": "在分布式系统中，如何保证时间字段一致性？",
    "keywords": "MySQL,时间类型,TIMESTAMP,DATETIME,存储优化"
  },
  {
    "id": "DB-010",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 隐式转换造成索引失效",
    "answer": "在 WHERE 条件中对索引列进行函数、类型转换会导致索引失效，例如 WHERE DATE(create_time)='2025-11-05'，会触发全表扫描。",
    "exam_points": "索引失效,隐式转换,查询优化,函数使用",
    "followups": "如何改写 SQL 保持索引生效？",
    "keywords": "MySQL,索引,优化,隐式转换,性能"
  },
  {
    "id": "DB-011",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "InnoDB 与 MyISAM 等存储引擎对比",
    "answer": "InnoDB 支持事务、行级锁、MVCC；MyISAM 不支持事务，使用表级锁，适合读多写少场景。InnoDB 是默认存储引擎，适合高并发 OLTP。",
    "exam_points": "事务支持,锁机制,存储引擎选择,并发性能",
    "followups": "在高并发写场景下，为什么选择 InnoDB？",
    "keywords": "MySQL,InnoDB,MyISAM,存储引擎,事务"
  },
  {
    "id": "DB-012",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 从 B 树到 B+ 树到索引再到存储引擎",
    "answer": "MySQL 使用 B+ 树实现大多数索引（主键、普通索引），叶子节点存储数据指针。存储引擎负责数据落盘与索引维护，优化查询性能。",
    "exam_points": "B+树索引,主键索引,存储引擎,B树演进",
    "followups": "为什么 InnoDB 用 B+ 树而非 B 树？",
    "keywords": "MySQL,B+树,索引,存储引擎,查询优化"
  },
  {
    "id": "DB-013",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 全文索引详解",
    "answer": "全文索引用于匹配文本内容，支持 MATCH...AGAINST 查询。InnoDB 支持英文全文索引和中文分词插件，适合搜索场景。",
    "exam_points": "全文索引,MATCH AGAINST,文本搜索,分词",
    "followups": "全文索引与 LIKE 查询性能对比？",
    "keywords": "MySQL,全文索引,文本搜索,InnoDB"
  },
  {
    "id": "DB-014",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 锁详解",
    "answer": "MySQL 锁包括表级锁、行级锁、意向锁、共享锁、排他锁。InnoDB 默认使用行级锁和 MVCC，提高并发性能。锁是事务控制和并发控制的核心。",
    "exam_points": "锁类型,行级锁,表级锁,意向锁,MVCC",
    "followups": "行锁与表锁在高并发场景下的性能差异？",
    "keywords": "MySQL,锁,事务,InnoDB,并发控制"
  },
  {
    "id": "DB-015",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 事务详解",
    "answer": "MySQL 事务具有 ACID 特性：原子性、一致性、隔离性、持久性。通过 InnoDB 实现，结合 redo log、undo log 保证事务可靠执行。",
    "exam_points": "事务特性,ACID,日志机制,InnoDB实现",
    "followups": "在并发场景下，如何选择合适的隔离级别？",
    "keywords": "MySQL,事务,ACID,InnoDB,并发控制"
  },
  {
    "id": "DB-016",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "mysqldump 工具命令参数大全",
    "answer": "mysqldump 是 MySQL 数据备份工具，可导出数据库或表结构和数据。常用参数：--databases, --tables, --single-transaction, --lock-tables, --routines。",
    "exam_points": "备份工具,参数说明,逻辑备份,数据恢复",
    "followups": "在高并发数据库备份中如何保证一致性？",
    "keywords": "MySQL,备份,mysqldump,数据恢复,参数"
  },
  {
    "id": "DB-017",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 索引面试易被刁难点",
    "answer": "面试官可能问索引失效场景（函数、隐式类型转换、范围查询）、覆盖索引、联合索引最左前缀原则、索引排序原理。",
    "exam_points": "索引失效,联合索引,最左前缀,覆盖索引",
    "followups": "如何设计联合索引满足查询需求？",
    "keywords": "MySQL,索引,联合索引,最左前缀,优化"
  },
  {
    "id": "DB-018",
    "module": "数据库",
    "difficulty": "中级",
    "type": "问答题",
    "title": "MySQL 乐观锁与悲观锁",
    "answer": "悲观锁假设并发冲突高，通过锁机制防止冲突（SELECT ... FOR UPDATE）；乐观锁假设冲突少，通过版本号或 CAS 保证数据一致性。",
    "exam_points": "悲观锁,乐观锁,并发控制,版本号,CAS",
    "followups": "在高并发写场景中，为什么推荐乐观锁？",
    "keywords": "MySQL,锁,乐观锁,悲观锁,事务"
  },
  {
    "id": "DB-019",
    "module": "数据库",
    "difficulty": "高级",
    "type": "问答题",
    "title": "MySQL 上亿大表优化方案",
    "answer": "优化方法包括：合理分库分表、索引优化、SQL 重写、分区表、冷热数据分离、缓存策略、慢查询分析和查询计划优化。",
    "exam_points": "大表优化,分库分表,索引优化,分区表,缓存",
    "followups": "如何监控优化后性能是否达标？",
    "keywords": "MySQL,大表优化,分区,索引,缓存"
  },
  {
    "id": "DB-020",
    "module": "数据库",
    "difficulty": "高级",
    "type": "问答题",
    "title": "SQL 优化常用技巧总结",
    "answer": "技巧包括：避免 SELECT *,使用覆盖索引,避免函数操作索引列,减少子查询,合理使用 JOIN 和 LIMIT,监控慢查询,批量插入优化。",
    "exam_points": "SQL优化,索引使用,查询重写,慢查询,批量操作",
    "followups": "在 OLTP 系统中，哪种优化最有效？",
    "keywords": "MySQL,SQL优化,索引,慢查询,性能"
  },
  {
    "id": "SB-001",
    "module": "SpringBoot",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Spring IoC（控制反转）详解",
    "answer": "IoC 是控制反转，通过容器负责对象的创建、依赖注入和生命周期管理。常用方式包括构造器注入、Setter 注入和 @Autowired 注解。",
    "exam_points": "IoC原理,依赖注入,Spring容器,Bean生命周期",
    "followups": "构造器注入和 Setter 注入有什么区别？为什么推荐构造器注入？",
    "keywords": "Spring,IoC,依赖注入,控制反转,Bean"
  },
  {
    "id": "SB-002",
    "module": "SpringBoot",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Spring AOP（面向切面编程）详解",
    "answer": "AOP 用于横切关注点，例如日志、事务、安全等。核心概念包括切点（Pointcut）、通知（Advice）、切面（Aspect）、代理（Proxy）。实现方式有 JDK 动态代理和 CGLIB 代理。",
    "exam_points": "AOP原理,切点,通知,切面,代理机制",
    "followups": "JDK 动态代理和 CGLIB 代理的区别？",
    "keywords": "Spring,AOP,切面,通知,代理"
  },
  {
    "id": "SB-003",
    "module": "SpringBoot",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Spring 事务详解",
    "answer": "Spring 事务管理支持编程式事务和声明式事务，基于 PlatformTransactionManager。通过 @Transactional 注解实现事务边界控制，结合事务传播行为和隔离级别。",
    "exam_points": "事务管理,@Transactional,传播行为,隔离级别,编程式事务",
    "followups": "为什么在私有方法中调用带 @Transactional 的方法不起作用？",
    "keywords": "Spring,事务,@Transactional,传播行为,隔离级别"
  },
  {
    "id": "SB-004",
    "module": "SpringBoot",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Spring 常用设计模式解析",
    "answer": "Spring 内部常用设计模式包括单例模式、工厂模式、代理模式、观察者模式和模板方法模式。例如 BeanFactory 使用工厂模式管理 Bean。",
    "exam_points": "设计模式应用,单例,工厂,代理,观察者",
    "followups": "Spring 的代理模式主要用于哪些功能？",
    "keywords": "Spring,设计模式,单例,代理,工厂"
  },
  {
    "id": "SB-005",
    "module": "SpringBoot",
    "difficulty": "中级",
    "type": "问答题",
    "title": "SpringBoot 自动装配原理详解",
    "answer": "Spring Boot 自动装配基于 @EnableAutoConfiguration 注解和 SpringFactoriesLoader，结合条件注解 @ConditionalOnXXX 自动装配 Bean，降低手动配置成本。",
    "exam_points": "自动装配,条件注解,@EnableAutoConfiguration,SpringFactoriesLoader",
    "followups": "如何自定义 Spring Boot 自动装配？",
    "keywords": "SpringBoot,自动装配,Conditional,EnableAutoConfiguration,Bean"
  },
  {
    "id": "SB-006",
    "module": "SpringBoot",
    "difficulty": "初级",
    "type": "问答题",
    "title": "Spring/Spring Boot 常用注解总结",
    "answer": "@Component、@Service、@Repository、@Controller/@RestController 用于 Bean 定义；@Autowired、@Qualifier 注入依赖；@Value 注入配置；@Configuration 配置类。",
    "exam_points": "核心注解,Bean管理,依赖注入,配置注入,RestController",
    "followups": "Spring Bean 注解与 Spring Boot 注解有什么区别？",
    "keywords": "Spring,注解,Autowired,Component,RestController"
  },
  {
    "id": "SB-007",
    "module": "SpringBoot",
    "difficulty": "初级",
    "type": "问答题",
    "title": "SpringBoot 入门指南",
    "answer": "Spring Boot 提供快速开发方案，通过 starter 依赖简化配置，内嵌 Tomcat，自动装配常用组件，支持 application.properties 或 application.yml 配置文件。",
    "exam_points": "快速启动,starter依赖,自动装配,内嵌容器,配置文件",
    "followups": "如何创建一个最小 Spring Boot 应用？",
    "keywords": "SpringBoot,入门,starter,自动装配,配置"
  },
  {
    "id": "SB-008",
    "module": "SpringBoot",
    "difficulty": "中级",
    "type": "问答题",
    "title": "IoC 与 AOP 面试高频问题",
    "answer": "面试常问 IoC 容器启动流程、Bean 生命周期、依赖注入方式以及 AOP 的代理实现、切面顺序、多切点组合等。",
    "exam_points": "IoC容器,Bean生命周期,依赖注入,AOP代理,切面顺序",
    "followups": "如果一个 Bean 被多个切面环绕，执行顺序如何确定？",
    "keywords": "Spring,IoC,AOP,面试题,代理"
  },
  {
    "id": "MQ-001",
    "module": "消息队列",
    "difficulty": "中级",
    "type": "问答题",
    "title": "消息队列的基本概念和作用",
    "answer": "消息队列是一种异步通信的中间件，主要作用包括削峰填谷、解耦系统、异步处理、流量削峰和消息可靠传递。",
    "exam_points": "异步通信,系统解耦,流量削峰,可靠性,消息传递模式",
    "followups": "在高并发场景下，消息队列如何帮助提高系统吞吐量？",
    "keywords": "消息队列,异步,解耦,削峰,可靠性"
  },
  {
    "id": "MQ-002",
    "module": "消息队列",
    "difficulty": "中级",
    "type": "问答题",
    "title": "消息队列常见类型及区别",
    "answer": "消息队列主要分为点对点（Queue）模式和发布/订阅（Topic）模式。Queue 保证消息只被一个消费者消费，Topic 可被多个订阅者同时消费。",
    "exam_points": "消息模型,点对点,发布订阅,消费者数量,消息分发",
    "followups": "什么时候优先选择 Queue 模式，什么时候选择 Topic 模式？",
    "keywords": "消息队列,点对点,发布订阅,消费模式"
  },
  {
    "id": "MQ-003",
    "module": "消息队列",
    "difficulty": "中级",
    "type": "问答题",
    "title": "消息队列可靠性保障机制",
    "answer": "常见可靠性机制包括消息持久化、消息确认（ACK）、重试机制、幂等性处理和死信队列（DLQ）。",
    "exam_points": "可靠性,消息持久化,ACK,重试,幂等性,死信队列",
    "followups": "如果消息被消费失败，如何保证不丢失且不重复消费？",
    "keywords": "消息队列,可靠性,持久化,ACK,幂等性,死信队列"
  },
  {
    "id": "MQ-004",
    "module": "消息队列",
    "difficulty": "高级",
    "type": "问答题",
    "title": "消息队列的顺序保证",
    "answer": "顺序消息通常通过同一队列或同一分区（Partition）保证顺序消费。Kafka 可通过 PartitionKey 保证分区内顺序，RabbitMQ 可通过单队列顺序保证。",
    "exam_points": "顺序消息,分区,队列,消费顺序,Kafka PartitionKey",
    "followups": "在高并发情况下如何保证全局顺序？",
    "keywords": "消息队列,顺序消息,队列,分区,Kafka,RabbitMQ"
  },
  {
    "id": "MQ-005",
    "module": "消息队列",
    "difficulty": "高级",
    "type": "问答题",
    "title": "消息队列性能优化思路",
    "answer": "优化手段包括批量发送、异步发送、减少同步阻塞、合理分区、压缩消息、消费者多线程消费和调整 ACK 策略。",
    "exam_points": "吞吐量优化,批量发送,异步发送,分区策略,多线程消费",
    "followups": "Kafka 和 RabbitMQ 在高吞吐量场景下的调优重点有哪些？",
    "keywords": "消息队列,性能优化,批量发送,异步,分区,吞吐量"
  },
  {
    "id": "MQ-006",
    "module": "消息队列",
    "difficulty": "中级",
    "type": "问答题",
    "title": "消息重复消费的解决方案",
    "answer": "主要通过幂等性处理、消息唯一 ID、事务型消息或消费端去重策略来避免消息重复处理带来的影响。",
    "exam_points": "重复消费,幂等性,消息唯一标识,事务消息,去重",
    "followups": "如何在分布式环境下保证消息的幂等性？",
    "keywords": "消息队列,重复消费,幂等性,事务消息,去重"
  },
  {
    "id": "MQ-007",
    "module": "消息队列",
    "difficulty": "高级",
    "type": "问答题",
    "title": "消息队列在分布式系统中的应用场景",
    "answer": "主要用于系统解耦、异步处理、削峰填谷、流量削峰、高并发场景的缓冲，以及实现事件驱动架构。",
    "exam_points": "系统解耦,异步处理,流量削峰,事件驱动,高并发",
    "followups": "在微服务架构中，消息队列的角色和使用注意事项有哪些？",
    "keywords": "消息队列,异步,解耦,事件驱动,高并发"
  },
  {
    "id": "MQ-008",
    "module": "消息队列",
    "difficulty": "高级",
    "type": "问答题",
    "title": "常见消息队列产品及特点",
    "answer": "RabbitMQ 基于 AMQP，可靠性高，支持复杂路由；Kafka 基于分布式日志，吞吐量高，顺序消息易管理；ActiveMQ、RocketMQ 各有特点适合不同场景。",
    "exam_points": "消息队列产品,RabbitMQ,Kafka,ActiveMQ,RocketMQ,应用场景",
    "followups": "如何选择适合自己业务场景的消息队列？",
    "keywords": "消息队列,RabbitMQ,Kafka,ActiveMQ,RocketMQ"
  },
  {
    "id": "MQ-009",
    "module": "消息队列",
    "difficulty": "高级",
    "type": "问答题",
    "title": "消息队列事务与分布式事务解决方案",
    "answer": "常见方案有本地事务+消息最终一致性、二阶段提交（2PC）、可靠消息服务、RocketMQ 事务消息、Kafka 事务保证等。",
    "exam_points": "分布式事务,事务消息,最终一致性,2PC,Kafka,RocketMQ",
    "followups": "如何在微服务架构中保证消息和数据库操作的强一致性？",
    "keywords": "消息队列,事务,分布式事务,最终一致性,事务消息"
  },{
  "id": "DP-001",
  "module": "设计模式",
  "difficulty": "中级",
  "type": "问答题",
  "title": "什么是设计模式？它的作用是什么？",
  "answer": "设计模式是前人在软件开发中总结出的可复用解决方案，用于解决特定场景下的设计问题。作用包括提高代码复用性、可维护性、可扩展性，并提升团队沟通效率。",
  "exam_points": "设计模式概念,作用,代码复用,可维护性,可扩展性",
  "followups": "你在实际项目中用过哪些设计模式？解决了什么问题？",
  "keywords": "设计模式,复用,可维护性,可扩展性,软件设计"
},
  {
    "id": "DP-002",
    "module": "设计模式",
    "difficulty": "中级",
    "type": "问答题",
    "title": "单例模式有什么实现方式？它们的区别是什么？",
    "answer": "常见实现方式有：饿汉式、懒汉式（线程不安全）、双重检查锁（DCL）、静态内部类、枚举。区别在于线程安全性、延迟加载和实现复杂度不同。",
    "exam_points": "单例模式,线程安全,延迟加载,双重检查锁,枚举实现",
    "followups": "在高并发场景下，你会选择哪种单例实现方式？为什么？",
    "keywords": "单例模式,线程安全,DCL,饿汉式,懒汉式"
  },
  {
    "id": "DP-003",
    "module": "设计模式",
    "difficulty": "中级",
    "type": "问答题",
    "title": "工厂模式与抽象工厂模式的区别？",
    "answer": "工厂模式（Factory Method）用于创建一类产品的实例，抽象工厂模式（Abstract Factory）用于创建一族相关或依赖的产品。工厂方法关注单一产品，抽象工厂关注产品族。",
    "exam_points": "工厂模式,抽象工厂,产品族,单一产品,解耦实例化",
    "followups": "实际项目中你会用哪种工厂模式？举例说明。",
    "keywords": "工厂模式,抽象工厂,设计模式,解耦,产品族"
  },
  {
    "id": "DP-004",
    "module": "设计模式",
    "difficulty": "中级",
    "type": "问答题",
    "title": "观察者模式的应用场景有哪些？",
    "answer": "观察者模式用于一对多依赖关系场景，典型应用包括事件监听器、消息推送、订阅-发布系统等。当目标对象状态变化时，自动通知所有观察者。",
    "exam_points": "观察者模式,一对多依赖,事件监听,订阅发布,解耦",
    "followups": "如何在 Java 中实现线程安全的观察者模式？",
    "keywords": "观察者模式,事件监听,订阅发布,解耦,多态"
  },
  {
    "id": "DP-005",
    "module": "设计模式",
    "difficulty": "高级",
    "type": "问答题",
    "title": "策略模式与状态模式的区别？",
    "answer": "策略模式（Strategy）用于在运行时动态选择算法，状态模式（State）用于对象在不同状态下行为不同。策略模式关注算法替换，状态模式关注对象状态转换。",
    "exam_points": "策略模式,状态模式,算法封装,状态转换,运行时行为",
    "followups": "举一个实际项目中使用策略模式优化代码的例子。",
    "keywords": "策略模式,状态模式,设计模式,运行时选择,行为变化"
  },
  {
    "id": "DP-006",
    "module": "设计模式",
    "difficulty": "高级",
    "type": "问答题",
    "title": "装饰器模式与代理模式有什么区别？",
    "answer": "装饰器模式用于在不修改原有类的情况下动态扩展功能，关注功能增强；代理模式用于控制对象访问，关注访问控制和方法调用，可做远程代理、延迟加载、权限校验等。",
    "exam_points": "装饰器模式,代理模式,功能增强,访问控制,设计模式区别",
    "followups": "在 Java 中，Spring AOP 实现的是装饰器模式还是代理模式？为什么？",
    "keywords": "装饰器模式,代理模式,功能增强,访问控制,设计模式"
  },
  {
    "id": "DP-007",
    "module": "设计模式",
    "difficulty": "高级",
    "type": "问答题",
    "title": "模板方法模式的作用和应用场景",
    "answer": "模板方法模式通过定义算法骨架，将部分步骤延迟到子类实现，实现代码复用和流程控制。应用场景包括通用算法流程抽象、框架设计、批处理任务等。",
    "exam_points": "模板方法,算法骨架,代码复用,子类扩展,框架设计",
    "followups": "如何用模板方法模式优化代码中的重复逻辑？",
    "keywords": "模板方法模式,算法骨架,代码复用,流程控制,设计模式"
  },{
  "id": "REDIS-001",
  "module": "Redis",
  "difficulty": "中级",
  "type": "问答题",
  "title": "Redis 的数据类型有哪些？",
  "answer": "Redis 支持五种核心数据类型：String、List、Set、Hash、Sorted Set (ZSet)，每种数据类型都有不同的应用场景和操作命令。",
  "exam_points": "数据类型,操作命令,应用场景,性能特点",
  "followups": "请举例说明每种数据类型的典型应用场景。",
  "keywords": "Redis,String,List,Set,Hash,ZSet"
},
  {
    "id": "REDIS-002",
    "module": "Redis",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Redis 支持持久化吗？有哪些方式？",
    "answer": "Redis 支持 RDB（快照方式）和 AOF（Append Only File，日志方式）两种持久化方式。RDB 定期保存数据快照，AOF 记录每条写命令并可重放恢复，二者可组合使用。",
    "exam_points": "RDB,AOF,持久化策略,数据恢复",
    "followups": "RDB 和 AOF 各自的优缺点是什么？在生产环境中如何选择？",
    "keywords": "Redis,持久化,RDB,AOF,数据恢复"
  },
  {
    "id": "REDIS-003",
    "module": "Redis",
    "difficulty": "中级",
    "type": "问答题",
    "title": "Redis 如何保证高性能？",
    "answer": "Redis 是单线程模型，通过内存存储数据、使用非阻塞 I/O、数据结构优化和事件驱动模型保证高性能。同时通过管道、批量操作、合理的 key 设计提升效率。",
    "exam_points": "单线程,内存存储,非阻塞I/O,事件驱动,管道优化",
    "followups": "Redis 单线程会成为性能瓶颈吗？如何解决？",
    "keywords": "Redis,高性能,单线程,内存存储,事件驱动"
  },
  {
    "id": "REDIS-004",
    "module": "Redis",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Redis 的事务如何实现？",
    "answer": "Redis 事务使用 MULTI、EXEC、WATCH 等命令实现。MULTI/EXEC 定义事务块，保证命令按顺序执行，WATCH 用于乐观锁控制事务冲突。Redis 事务不支持回滚，只保证命令的原子性执行。",
    "exam_points": "事务,MULTI,EXEC,WATCH,乐观锁,原子性",
    "followups": "Redis 事务和关系型数据库事务的区别是什么？",
    "keywords": "Redis,事务,MULTI,EXEC,WATCH,乐观锁"
  },
  {
    "id": "REDIS-005",
    "module": "Redis",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Redis 常用的缓存策略有哪些？",
    "answer": "常用缓存策略包括 LRU（最近最少使用）、LFU（最少使用）、FIFO（先进先出）、TTL（过期时间）等，用于管理内存数据淘汰和缓存失效。",
    "exam_points": "缓存策略,LRU,LFU,FIFO,TTL,内存管理",
    "followups": "Redis 如何配置和实现 LRU 淘汰策略？",
    "keywords": "Redis,缓存策略,LRU,LFU,FIFO,TTL"
  },
  {
    "id": "REDIS-006",
    "module": "Redis",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Redis 分布式部署常用方案有哪些？",
    "answer": "Redis 分布式部署方案主要有主从复制（Master-Slave）、哨兵模式（Sentinel）和 Cluster 集群模式。主从复制实现数据冗余，Sentinel 提供高可用，Cluster 提供数据分片和横向扩展。",
    "exam_points": "主从复制,哨兵模式,Cluster,高可用,数据分片",
    "followups": "Redis Cluster 如何保证数据一致性和高可用？",
    "keywords": "Redis,分布式,主从,哨兵,Cluster,高可用"
  },
  {
    "id": "REDIS-007",
    "module": "Redis",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Redis 的内存优化和对象存储优化策略？",
    "answer": "Redis 内存优化策略包括合理设置 key 大小、使用压缩数据结构（hash ziplist, list quicklist）、设置过期时间、使用内存回收策略以及避免大对象存储。",
    "exam_points": "内存优化,key设计,压缩数据结构,过期策略,大对象处理",
    "followups": "如何在 Redis 中避免内存碎片问题？",
    "keywords": "Redis,内存优化,压缩数据结构,key设计,大对象"
  },
  {
    "id": "REDIS-008",
    "module": "Redis",
    "difficulty": "高级",
    "type": "问答题",
    "title": "Redis 如何实现分布式锁？",
    "answer": "Redis 分布式锁通常使用 SET key value NX PX 或 RedLock 算法实现。SET NX 保证原子性，PX 设置过期时间防止死锁，RedLock 通过多个 Redis 节点保证高可用。",
    "exam_points": "分布式锁,SET NX PX,RedLock,原子性,高可用",
    "followups": "在高并发场景下，如何保证 Redis 分布式锁的可靠性？",
    "keywords": "Redis,分布式锁,SET NX PX,RedLock,高可用"
  }
]
